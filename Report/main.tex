\documentclass[conference]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{braket}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{subcaption} 

\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}



\begin{document}

\title{Quantum Error Correction (EE7001)}

\author{
    \IEEEauthorblockN{Tanay Bhat}
    \IEEEauthorblockA{
        Department of Electrical Engineering \\
        Indian Institute of Technology, Bombay \\
        Mumbai, India \\
        Email: 22b3303@iitb.ac.in
    }
    \and
    \IEEEauthorblockN{Jay Mehta}
    \IEEEauthorblockA{
        Department of Electrical Engineering \\
        Indian Institute of Technology, Bombay \\
        Mumbai, India \\
        Email: 22b1281@iitb.ac.in
    }
    \and
    \IEEEauthorblockN{Rajwardhan Toraskar}
    \IEEEauthorblockA{
        Department of Electrical Engineering \\
        Indian Institute of Technology, Bombay \\
        Mumbai, India \\
        Email: 22b0721@iitb.ac.in
    }
}

\maketitle

\begin{abstract}
    Quantum Error Correction (QEC) draws inspiration from classical error correction techniques to safeguard against errors. The 3-bit code serves as a starting point, being able to correct single bit-flip errors. This was then extended by Shor to the 9-bit code, which can correct both bit-flip and phase-flip errors. We shall also review bipartite purification protocols like the BBPSSW protocol and the DEJMPS protocol, which enhance the fidelity of entangled states which is crucial for quantum communication. 
\end{abstract}

\section{Introduction}
Quantum mechanics fundamentally changed our understanding of nature, revealing phenomena such as superposition and entanglement that defy classical intuition. Among these, entanglement has emerged as a cornerstone of modern quantum information science. Once regarded primarily as a conceptual puzzle, entanglement is now recognized as a key resource enabling quantum communication, computation, and cryptography. Experimental progress across diverse platforms—photons, trapped ions, atomic ensembles, superconducting circuits—has transformed theoretical proposals into tangible technologies. Yet, the practical realization of large-scale quantum systems remains limited by the inherent fragility of quantum coherence.

Every quantum system interacts inevitably with its surrounding environment, leading to noise and decoherence that degrade quantum states and destroy entanglement. Maintaining high-fidelity quantum information is therefore one of the most pressing challenges in the field. Two complementary strategies have been developed to combat these errors: entanglement purification and quantum error correction (QEC). Both aim to protect and restore the integrity of quantum information, albeit through different mechanisms.

Entanglement purification addresses the problem of distributing and maintaining entanglement over noisy quantum channels. By locally manipulating multiple imperfect copies of an entangled state and exchanging classical information, distant parties can probabilistically distill a smaller number of states with higher fidelity. Such purified entangled pairs can then serve as reliable channels for quantum teleportation, forming the foundation of quantum repeaters that enable long-distance quantum communication. These protocols, often relying on local operations and two-way classical communication, connect naturally with the principles of QEC—both can be seen as strategies to recover lost coherence and fidelity.

Quantum error correction, in contrast, provides an active and systematic framework for protecting unknown quantum states during computation or transmission. By encoding logical qubits into larger Hilbert spaces of multiple physical qubits, QEC enables the detection and correction of errors without direct measurement of the encoded information. The development of the first quantum codes in 1995 demonstrated that reliable, large-scale quantum computation was in principle possible. Subsequent advances introduced the stabilizer formalism, concatenated codes, and fault-tolerant architectures capable of withstanding realistic error rates below certain thresholds. Modern extensions—including subsystem and topological codes—offer powerful and scalable means of achieving fault-tolerant quantum processing.

Together, entanglement purification and quantum error correction constitute the theoretical backbone of fault-tolerant quantum information processing. They transform the unavoidable imperfections of physical systems into manageable errors, bridging the gap between fragile quantum hardware and the robust manipulation of information necessary for the future of quantum technologies.

This report will majorly summarise the findings of \cite{paper1} and \cite{paper2}.

\section{Quantum Errors}
We must note that coding based on data redundancy is not directly applicable to quantum information due to the no-cloning theorem, which prohibits the creation of identical copies of an arbitrary unknown quantum state. We also cannot perform direct measurements on qubits to detect errors, as this would collapse their superposition states. Additionally, quantum errors can be more complex as they are continuous in nature, unlike classical errors which are typically discrete (bit-flip or no bit-flip). QEC essentially relies on using data redundancy in a more sophisticated manner, encoding a single logical qubit into multiple physical qubits to protect against errors. Let us consider some common types of quantum errors.

\subsection{Types of Quantum Errors}

Consider the following two operations on a qubit:
\begin{itemize}
    \item \begin{equation}
        | \psi \rangle = \prod_{i = 1}^{N} I_i |0\rangle = |0 \rangle
    \end{equation}

    \item \begin{equation}
        | \psi \rangle = HIH |0\rangle = |0 \rangle
    \end{equation}
\end{itemize}

Note that these operations are functionally equivalent to $\sigma_I$ gate and are useful for understanding quantum errors.
\vspace{4pt}
\subsubsection{Coherent Errors}
These types of errors arise due to incorrect application of quantum gates. Such errors are systematic and can accumulate over time, leading to significant deviations from the intended quantum state. Consider the case where a small rotation is applied to a qubit. This results in the following state:

\begin{equation}
    | \psi \rangle = \prod_{i = 1}^{N} e^{i \epsilon \sigma_X} |0\rangle = \cos(N \epsilon ) |0\rangle + i \sin(N \epsilon) |1\rangle
\end{equation}

Hence $P(|0\rangle) = \cos^2(N \epsilon) \approx 1 - (N \epsilon)^2$ and $P(|1\rangle) = \sin^2(N \epsilon) \approx (N \epsilon)^2$. Hence error of order $O(\epsilon^2)$ has been introduced. We shall see that the 3-bit code can be used to supress such errors to $O(\epsilon^6)$.

\vspace{4pt}
\subsubsection{Environmental Decoherence}
Consider a system where the environment exists as orthogonal states $|e_0\rangle$ and $|e_1\rangle$. We also assume that the state of the environment flips if the coupled qubit is $|1\rangle$ else there is no change. Hence on application of the operation $HIH$ to the state $|0\rangle |e_0\rangle$, we get:

\begin{equation}
    | \psi \rangle = HIH |0\rangle |e_0\rangle = \frac{1}{2} (|0\rangle + |1\rangle) |e_0\rangle + \frac{1}{2} (|0\rangle - |1\rangle) |e_1\rangle
\end{equation}

This results in the following density matrix:

\begin{equation}
    \begin{aligned}
        \rho &= |\psi\rangle \langle \psi| \\
        &= \frac{1}{4} (|0\rangle + |1\rangle)(\langle 0| + \langle 1|) |e_0\rangle \langle e_0| \\
        &+ \frac{1}{4} (|0\rangle + |1\rangle)(\langle 0| - \langle 1|) |e_0\rangle \langle e_1| \\
        &+ \frac{1}{4} (|0\rangle - |1\rangle)(\langle 0| + \langle 1|) |e_1\rangle \langle e_0| \\
        &+ \frac{1}{4} (|0\rangle - |1\rangle)(\langle 0| - \langle 1|) |e_1\rangle \langle e_1|
    \end{aligned}
\end{equation}

We can trace out the environment to get the reduced density matrix of the qubit as:

\begin{equation}
    \rho_q = \frac{1}{2} (|0\rangle \langle 0| + |1\rangle \langle 1|)
\end{equation}

Hence on measurement of the qubit, we get $|0\rangle$ or $|1\rangle$ with equal probability and hence the qubit has completely decohered.

\vspace{4pt}
\subsubsection{Loss, Leakage, Measurement and Initialization Errors}

In addition to coherent control errors and environmental decoherence, practical quantum devices experience several other imperfections such as qubit loss, leakage, measurement inaccuracies, and imperfect initialization. These can be modeled either coherently or incoherently depending on their physical origin.

\textbf{Measurement Errors:} Measurement noise is commonly modeled as an incoherent process. Two equivalent formulations are typically used.

\textit{(i) POVM Model:} The measurement operators are
\begin{equation}
        \begin{aligned}
            F_0 &= (1-p_M)|0\rangle\langle 0| + p_M |1\rangle\langle 1| \\
            F_1 &= (1-p_M)|1\rangle\langle 1| + p_M |0\rangle\langle 0|
        \end{aligned}
\end{equation}
where $p_M$ denotes the measurement error probability. Since $F_i^2 \neq F_i$, the operators are non-projective. The corresponding outcome probabilities are
\begin{equation}
\mathrm{Tr}(F_0\rho) = (1-p_M)\mathrm{Tr}(A_0\rho) + p_M \mathrm{Tr}(A_1\rho),
\end{equation}
\begin{equation}
\mathrm{Tr}(F_1\rho) = (1-p_M)\mathrm{Tr}(A_1\rho) + p_M \mathrm{Tr}(A_0\rho),
\end{equation}
where $A_0 = |0\rangle\langle 0|$ and $A_1 = |1\rangle\langle 1|$.  
The post-measurement state is given by
\begin{equation}
\rho \rightarrow \frac{M_i \rho M_i^\dagger}{\mathrm{Tr}(F_i\rho)}, \quad
M_0 = \sqrt{1-p_M}|0\rangle\langle 0| + \sqrt{p_M}|1\rangle\langle 1|.
\end{equation}
Thus, the measured qubit remains in a superposed state rather than collapsing completely into a basis vector.

\textit{(ii) Bit-Flip Channel Model:} Alternatively, measurement error can be modeled as a bit-flip with probability $p_M$, followed by an ideal measurement:
\begin{equation}
\rho \rightarrow \rho' = (1-p_M)\rho + p_M X\rho X,
\end{equation}
where $X$ is the Pauli-$X$ operator. Both models yield the same measurement statistics but differ in the post-measurement states. The POVM model leaves residual coherence, while the bit-flip model projects the state directly onto $|0\rangle$ or $|1\rangle$.  
For instance, for $|\psi\rangle = \tfrac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$, the POVM model produces $\sqrt{1-p_M}|0\rangle + \sqrt{p_M}|1\rangle$, whereas the bit-flip model yields $|0\rangle$.  
In practical systems, since qubits are reinitialized immediately after measurement, either approach provides equivalent results for simulation purposes.

\textbf{Qubit Loss:} Qubit loss refers to the disappearance of the physical information carrier from the system. It can be modeled by tracing out the lost subsystem:
\begin{equation}
\rho \rightarrow \mathrm{Tr}_i(\rho),
\end{equation}
which effectively reduces the Hilbert space dimension by a factor of two.  
Since standard QEC protocols assume that qubits remain physically accessible, loss correction typically requires a non-demolition detection mechanism to verify qubit presence without perturbing its logical state. The detection of a loss event can serve as a herald, allowing the replacement of the missing qubit and improving overall error resilience.

\textbf{Initialization Errors:} Initialization imperfections can manifest as either incoherent or coherent errors. Incoherent initialization can be represented as a probabilistic mixture:
\begin{equation}
\rho_i = (1-p_I)|0\rangle\langle 0| + p_I |1\rangle\langle 1|,
\end{equation}
whereas a coherent initialization error corresponds to preparing a slightly rotated pure state:
\begin{equation}
|\psi_i\rangle = \alpha|0\rangle + \beta|1\rangle, \quad |\alpha|^2 + |\beta|^2 = 1, \quad |\beta|^2 \ll 1.
\end{equation}
Both forms increase the probability of incorrect measurement outcomes, effectively lowering the fidelity of qubit preparation.

\textbf{Qubit Leakage:} Leakage occurs when the system state escapes the computational subspace $\{|0\rangle, |1\rangle\}$ into higher excited levels such as $|2\rangle$. In an ion-trap qubit, for example, an imperfect pulse may produce
\begin{equation}
U|0\rangle = \alpha|0\rangle + \beta|1\rangle + \gamma|2\rangle.
\end{equation}
Such leakage violates the two-level approximation and introduces additional decoherence if the higher level $|2\rangle$ decays rapidly.  
Mitigation strategies include:  
(i) Non-demolition verification to ensure the qubit remains within the computational manifold, and  
(ii) Pulse refocusing sequences that coherently return leaked population back to the logical subspace.  

Leakage can arise from both dynamic control errors and fabrication imperfections. The latter can be mitigated by post-fabrication characterization and exclusion of faulty qubits, reducing the necessity for active leakage correction.

\textbf{Summary:} Loss, leakage, measurement, and initialization errors all contribute to the non-ideal behavior of quantum devices. Accurate modeling of these processes as coherent or incoherent quantum channels is crucial for the development of reliable quantum error correction and fault-tolerant architectures.


\section{Entanglement Purification and QEC}
We can transmit quantum information over a channel using teleportation. Recall that teleportation involves the users Alice and Bob to share a maximally entangled state (like $| \phi^+ \rangle$) and then Alice performing a Bell measurement on her half of the entangled state and the qubit to be transmitted. She then sends the result of the measurement to Bob over a classical channel, who then applies a unitary operation on his half of the entangled state to get the original qubit. However in the presence of a noisy channel, the act of sending one half of the entangled state to Bob will result in a noisy non-maximally entagled state. This in turn affects the fidelity of the teleported qubit. To combat this, multiple copies of the noisy entangled state are produced and then purified using entanglement purification which essentially means increasing entanglement of a few copies. \par

These purification protocols can be categorized as distillation, recurrence and pumping schemes. Distillation involves applying local operations to multiple copies of noisy states to generate a few states with higher fidelity. The latter two involved repeating the purification step multiple times to improve the fidelity of states.
\section{3-bit and 9-bit Shor Code}
\subsection{The 3-Qubit Bit-Flip Code}
\subsubsection{Why the 3-Qubit Code Works}

The 3-qubit bit-flip code protects a single logical qubit against a single $\sigma_x$ (bit-flip) error by encoding it redundantly across three physical qubits. The logical basis states are:

\begin{equation}
|0\rangle_L = |000\rangle, \quad |1\rangle_L = |111\rangle
\end{equation}

An arbitrary qubit state
\begin{equation}
|\psi\rangle = \alpha |0\rangle + \beta |1\rangle
\end{equation}
is mapped to the encoded state
\begin{equation}
|\psi\rangle_L = \alpha |0\rangle_L + \beta |1\rangle_L = \alpha |000\rangle + \beta |111\rangle.
\end{equation}

The code works because the minimum Hamming distance between the codewords is $d = 3$, meaning that at least three bit flips are required to transform $|0\rangle_L \leftrightarrow |1\rangle_L$. This allows correction of a single bit-flip error, as the corrupted state remains closer to the original logical state. The number of correctable errors $t$ is related to $d$ by:
\begin{equation}
t = \left\lfloor \frac{d-1}{2} \right\rfloor = 1.
\end{equation}

\subsubsection{How the 3-Qubit Code Works}

Error correction uses two ancilla qubits to extract a \textit{syndrome} without measuring the logical qubit directly. After applying CNOT gates to check parity, the ancilla measurement reveals which, if any, qubit has flipped. For instance, the ancilla measurement outcomes and corresponding corrections are:

\begin{equation}
\begin{aligned}
\ket{00} &\quad \text{No error} \\
\ket{01} &\quad \sigma_x \text{ on qubit 3} \\
\ket{10} &\quad \sigma_x \text{ on qubit 2} \\
\ket{11} &\quad \sigma_x \text{ on qubit 1}
\end{aligned}
\end{equation}

For coherent rotation errors $U = \exp(i \epsilon \sigma_x)$ on each qubit, the total error operator is
\begin{equation}
    \begin{aligned}
        E = U^{\otimes 3} &= (\cos \epsilon\, \sigma_I + i \sin \epsilon\, \sigma_x)^{\otimes 3} \\
        &= c_0 \sigma_I \sigma_I \sigma_I + c_1 (\sigma_x \sigma_I \sigma_I + \dots) \\
        &\quad + c_2 (\dots) + c_3 \sigma_x \sigma_x \sigma_x
    \end{aligned}
\end{equation}
with
\begin{equation}
    \begin{aligned}
        c_0 &= \cos^3 \epsilon, \\
        c_1 &= i \cos^2 \epsilon \sin \epsilon, \\
        c_2 &= -\cos \epsilon \sin^2 \epsilon, \\
        c_3 &= -i \sin^3 \epsilon.
    \end{aligned}
\end{equation}

After error correction and ancilla measurement, the encoded qubit fidelity is improved from
\begin{equation}
F_{\text{unencoded}} = \cos^2 \epsilon \approx 1 - \epsilon^2
\end{equation}
to
\begin{equation}
F_{\text{encoded}} \approx 1 - \epsilon^6
\end{equation}
if no error is detected.

\subsection{The 9-Qubit Shor Code}

\subsubsection{Why the 9-Qubit Code Works}

The 9-qubit Shor code extends the 3-qubit repetition code to correct both single bit-flip ($\sigma_x$) and phase-flip ($\sigma_z$) errors. The logical states are

\begin{equation}
\begin{aligned}
|0\rangle_L &= \frac{1}{2\sqrt{2}} (|000\rangle + |111\rangle)(|000\rangle + |111\rangle)(|000\rangle + |111\rangle), \\
|1\rangle_L &= \frac{1}{2\sqrt{2}} (|000\rangle - |111\rangle)(|000\rangle - |111\rangle)(|000\rangle - |111\rangle).
\end{aligned}
\end{equation}

Each block of three qubits can correct a single $\sigma_x$ error, while phase errors are corrected by comparing relative phases between the three blocks. The code is \textit{degenerate}, meaning different errors may have the same effect on the logical state, allowing more flexibility in correction.

\subsubsection{How the 9-Qubit Code Works}

Bit-flip correction is applied independently to each 3-qubit block using the same parity check as in the 3-qubit code. Phase-flip correction uses CNOT gates to compare the signs between blocks. For example, a phase-flip $\sigma_z$ on a qubit changes the relative phase in its block, which is detected by the inter-block parity check.

The error operator for coherent rotations can be generalized as
\begin{equation}
E = \bigotimes_{i=1}^{9} (\cos \epsilon\, \sigma_I + i \sin \epsilon\, \sigma_x),
\end{equation}
and the combination of X and Z correction circuits restores the logical qubit to a higher fidelity state than the unencoded qubit. The Shor code is thus a full quantum error correcting code capable of correcting arbitrary single-qubit errors.

\section{Stabilizer Codes}

\subsection{Stabilizer Formalism}

The stabilizer formalism \cite{paper1} provides a compact and general 
framework for describing a large class of quantum error-correcting codes, known 
as stabilizer codes. Instead of representing states in the Schr\"odinger picture, 
the formalism uses the Heisenberg representation, characterizing quantum states 
by the operators that leave them invariant.

\subsubsection{Stabilized States}

A pure state $\ket{\psi}$ is \emph{stabilized} by an operator $K$ if it is a 
$+1$ eigenstate:
\begin{equation}
    K\ket{\psi} = \ket{\psi}. \label{eq:stab_def}
\end{equation}

For example:
\begin{equation}
    \sigma_z \ket{0} = \ket{0}.
\end{equation}

\subsubsection{Pauli Group}

The single-qubit Pauli group is
\begin{equation}
    P = \{\pm I, \pm iI, \pm X, \pm iX, \pm Y, \pm iY, \pm Z, \pm iZ \}.
\end{equation}

Pauli operators satisfy
\begin{align}
    [\sigma_i, \sigma_j] &= 2 i \epsilon_{ijk} \sigma_k, \\
    \{\sigma_i, \sigma_j\} &= 2 \delta_{ij},
\end{align}

The $N$-qubit Pauli group is defined as
\begin{equation}
    P_N = P^{\otimes N}.
\end{equation}

\subsubsection{Stabilizer Group}

An $N$-qubit stabilizer state $\ket{\psi}_N$ is defined by an Abelian subgroup 
$G \subseteq P_N$ generated by commuting Pauli operators $K_i$ satisfying:
\begin{equation}
    G = \{K_i \mid K_i \ket{\psi} = \ket{\psi}, \; [K_i, K_j]=0\}. 
\end{equation}

Since stabilizers are Hermitian with eigenvalues $\pm 1$, they obey
\begin{equation}
    K^2 = I.
\end{equation}

\subsubsection{Examples of Stabilizer States}

\paragraph{GHZ State.}

The three-qubit GHZ state is
\begin{equation}
    \ket{\text{GHZ}}_3 = \frac{\ket{000} + \ket{111}}{\sqrt{2}}.
\end{equation}

A possible stabilizer generator set is:
\begin{align}
    K_1 &= X \otimes X \otimes X = XXX, \\
    K_2 &= Z \otimes Z \otimes I = ZZI, \\
    K_3 &= I \otimes Z \otimes Z = IZZ.
\end{align}

\paragraph{Bell States.}

The four Bell states are
\begin{align}
    \Phi^{\pm} &= \frac{\ket{00} \pm \ket{11}}{\sqrt{2}}, \\
    \Psi^{\pm} &= \frac{\ket{01} \pm \ket{10}}{\sqrt{2}}.
\end{align}

They are joint eigenstates of $XX$ and $ZZ$.  
Let the eigenvalues be $(-1)^a$ and $(-1)^b$ with $a,b \in \{0,1\}$:
\begin{align}
    K_1 &= (-1)^a XX, \\
    K_2 &= (-1)^b ZZ.
\end{align}

Correspondence:
\begin{align}
    \Phi^{+} &: (K_1 = XX,\; K_2 = ZZ), \\
    \Phi^{-} &: (K_1 = -XX,\; K_2 = ZZ), \\
    \Psi^{+} &: (K_1 = XX,\; K_2 = -ZZ), \\
    \Psi^{-} &: (K_1 = -XX,\; K_2 = -ZZ).
\end{align}

These stabilizer eigenvalue signatures uniquely specify each Bell state.

\subsection{Quantum Error Correction with Stabilizer Codes}

Stabilizer codes define a logical coding subspace as the simultaneous $+1$ eigenspace of a set of commuting
Pauli operators. This formalism provides a compact description of large quantum codes, enables systematic
circuit synthesis for encoding and decoding, and makes the structure of logical operators transparent.

\subsection{Reduction of Hilbert Space Using Stabilizers}

A stabilizer projector restricts the full Hilbert space to a smaller subspace of states fixed by the
stabilizer group. For example, consider a 2-qubit system constrained by the stabilizer $XX$. Only the two
states
\begin{equation}
|0\rangle_L = \frac{1}{\sqrt{2}} \left( |01\rangle + |10\rangle \right)
\end{equation}
\begin{equation}
|1\rangle_L = \frac{1}{\sqrt{2}} \left( |00\rangle + |11\rangle \right)
\end{equation}

satisfy $XX|\psi\rangle = +|\psi\rangle$. Thus two physical qubits encode a single logical qubit. More generally,
for $n$ qubits and $k$ independent stabilizer generators, the logical subspace has dimension $2^{n-k}$.

\subsection{The 7-Qubit Steane Code}

The Steane code is a $[[7,1,3]]$ CSS code encoding one logical qubit and correcting a single arbitrary
Pauli error. The six stabilizers
\begin{equation}
K_1,\,K_2,\,K_3 \;\text{(X-type)}, 
\qquad
K_4,\,K_5,\,K_6 \;\text{(Z-type)}.
\end{equation}

define a two-dimensional logical subspace. The logical operator $Z_L = Z^{\otimes 7}$ distinguishes the two
logical basis states $|0\rangle_L$ and $|1\rangle_L$. The separation into $X$- and $Z$-sector stabilizers
identifies this as a CSS code, simplifying both encoding and fault-tolerant logical gate construction.

Other stabilizer codes include the $[[9,1,3]]$ Shor code and the $[[5,1,3]]$ non-CSS code, the smallest code
capable of correcting a single qubit error.

\subsection{State Preparation Using Stabilizers}

\subsubsection*{Projection into Stabilizer Eigenspaces}
A valid codeword is a simultaneous $+1$ eigenstate of all stabilizer generators. To project an arbitrary input
state into this subspace, we perform an ancilla-assisted ``parity measurement,'' shown in Fig.~7. For any
Hermitian stabilizer $U$,
\begin{equation}
|\psi\rangle_I \;\longrightarrow\;
\frac{1}{2}\!\left( |\psi\rangle_I \pm U|\psi\rangle_I \right).
\end{equation}

where the sign is determined by the measurement outcome of the ancilla. The resulting post-measurement state
is the $\pm1$ eigenstate of $U$. Repeating this procedure for each stabilizer generator projects the initial
state into the code space.

\subsubsection*{State Preparation for the Steane Code}
To prepare the logical $|0\rangle_L$:

\begin{enumerate}
    \item Initialize the seven physical qubits in $|0\rangle^{\otimes 7}$.
    \item Measure the three X-type stabilizers $K_1, K_2, K_3$ in parallel using ancillas.
    \item Each measurement may return $+1$ or $-1$. Any $-1$ outcome indicates that the state has been 
          projected into the $-1$ eigenspace of that stabilizer.
    \item Apply a classically-controlled single-qubit $Z$ correction to convert each $-1$ outcome into the
          desired $+1$ outcome. For the Steane code, a single corrective $Z$ on qubit 
          $i = 1^{M_2} + 2^{M_3} + 4^{M_1}$ suffices (where $M_j$ are ancilla measurement results).
    \item The Z-type stabilizers $K_4, K_5, K_6$ need not be measured, because $|0\rangle^{\otimes 7}$ is
          already a $+1$ eigenstate of all Z-type operators.
\end{enumerate}

Thus, the final state is guaranteed to lie in the joint $+1$ eigenspace of all six stabilizers, i.e., the
logical $|0\rangle_L$. This procedure generalizes to other stabilizer codes, such as the 5-qubit code, whose
logical basis states can be obtained by successively projecting $|00000\rangle$ into the $+1$ eigenspace of
its four stabilizers.

\subsection{Error Correction in Stabilizer Codes}

\subsubsection*{Syndrome Extraction}
Let $E$ be an error acting on the encoded logical state $|\psi\rangle_L = \alpha|0\rangle_L + \beta|1\rangle_L$.
The effect of each stabilizer generator $K_i$ is
\begin{equation}
K_i E |\psi\rangle_L =
\begin{cases}
+\,E|\psi\rangle_L, & \text{if } [K_i, E] = 0, \\[4pt]
-\,E|\psi\rangle_L, & \text{if } \{K_i, E\} = 0,
\end{cases}
\end{equation}

so errors manifest as sign flips (i.e.\ ``syndrome bits'') in stabilizer measurement outcomes. Each error has a
distinct syndrome, allowing its location and type to be determined.

\subsubsection*{Error Correction for the Steane Code}
For the $[[7,1,3]]$ code:

\begin{itemize}
    \item $Z$ errors anticommute with the X-type stabilizers $(K_1,K_2,K_3)$.
    \item $X$ errors anticommute with the Z-type stabilizers $(K_4,K_5,K_6)$.
    \item A $Y$ error (i.e., $iXZ$) triggers syndromes in both sectors.
\end{itemize}

Thus, measuring all six stabilizers identifies the unique pattern of flipped signs corresponding to each
single-qubit Pauli error. After identifying the error, the corresponding corrective Pauli operator is applied.

\subsubsection*{General Structure}
In any $[[n,k,d]]$ stabilizer code:
\begin{enumerate}
    \item Measure all $n-k$ stabilizers to obtain a binary syndrome of length $n-k$.
    \item Use the syndrome to identify a Pauli error consistent with the code distance.
    \item Apply the inverse Pauli operator to restore the encoded state.
\end{enumerate}

This process, an extension of the stabilizer-based state preparation circuit, forms the foundation of
stabilizer-based quantum error correction.



\section{Digitization of Quantum Errors}

Up to this point, quantum error correction (QEC) has been described assuming a \emph{discrete} set of Pauli errors occurring at specific circuit locations. In realistic quantum systems, noise arises from coherent gate imperfections and environmental decoherence, both of which are continuous processes. This section explains how stabilizer-based QEC \emph{digitizes} arbitrary continuous noise into discrete Pauli errors by syndrome measurement.

The key idea:  
\textbf{Syndrome measurements project arbitrary errors into discrete Pauli errors.}

Codewords are eigenstates of stabilizers. Any continuous corruption places the state into superpositions across stabilizer eigenspaces; measuring stabilizers collapses the state into one eigenspace, yielding a discrete error syndrome. Thus, continuous noise is mapped to discrete Pauli errors with certain probabilities.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Systematic Gate Errors}

Systematic errors arise when an intended $N$-qubit unitary $U_N$ is executed imperfectly, so that the actual operation is
\begin{equation}
    U'_N = U_E U_N ,
\end{equation}

where $U_E$ is a coherent error unitary.

Given an encoded state $\lvert \psi\rangle_L$, the faulty gate produces
\begin{equation}
U'_N \lvert \psi\rangle_L 
= U_E U_N \lvert \psi\rangle_L
= \sum_j \alpha_j E_j \lvert \psi'\rangle_L .
\end{equation}

where:
\begin{itemize}
\item $\lvert \psi'\rangle_L = U_N \lvert \psi\rangle_L$ is the ideal output,
\item $E_j \in \mathcal{P}_N$ are $N$-qubit Pauli operators,
\item $\alpha_j$ are real amplitudes,
\item We assume (for illustration) each $E_j$ has weight $\le 1$.
\end{itemize}

To perform correction, two ancilla blocks $\lvert A_0\rangle^X$ and $\lvert A_0\rangle^
Z$ are used. Syndrome extraction by $U_{\mathrm{QEC}}$ yields
\begin{equation}
U_{\mathrm{QEC}} U'_N \lvert \psi\rangle_L \lvert A_0\rangle^X \lvert A_0\rangle^Z
=
\sum_j \alpha_j E_j \lvert \psi'\rangle_L \lvert A_j\rangle^X \lvert A_j\rangle^Z .
\end{equation}


Measurement of the ancilla collapses the logical block into:
\begin{equation}
E_j \lvert \psi'\rangle_L 
\quad \text{with probability } |\alpha_j|^2 .
\end{equation}

after which $E_j^\dagger$ is applied to correct the error.

For a well-designed gate,
\begin{equation}
|\alpha_0| \approx 1, 
\qquad 
|\alpha_{j\neq 0}| \ll 1 .
\end{equation}

so most of the time no error is detected. This collapse of a continuous error $U_E$ into discrete Pauli errors constitutes the \textbf{digitization effect of QEC}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Environmental Decoherence}

Environmental noise is described using the Lindblad master equation:
\begin{equation}
\partial_t \rho 
= -\frac{i}{\hbar}[H,\rho] 
+ \sum_k \Gamma_k\, \mathcal{L}_k[\rho] .
\end{equation}

where each Lindblad operator $L_k$ contributes incoherent evolution via:
\begin{equation}
\mathcal{L}_k[\rho] 
= \frac{1}{2}\!\left( 
\big[ L_k,\, \rho L_k^\dagger \big]
+ \big[ L_k \rho,\, L_k^\dagger \big]
\right).
\end{equation}


Consider a single qubit undergoing:
\begin{itemize}
\item dephasing: $L_1 = Z$,
\item spontaneous emission: $L_2 = \lvert 0\rangle\langle 1\rvert$,
\item spontaneous absorption: $L_3 = \lvert 1\rangle\langle 0\rvert$,
\end{itemize}
with identical rates $\Gamma$ (for simplicity). Then
\begin{equation}
\partial_t \rho
= -\frac{i}{\hbar}[H,\rho]
+ \Gamma_Z \big( Z\rho Z - \rho \big)
+ \frac{\Gamma}{2}\big( X\rho X + Y\rho Y - 2\rho \big).
\end{equation}


If $H = 0$, write
\begin{equation}
\rho(t) = \frac{I}{2} + x(t)X + y(t)Y + z(t)Z .
\end{equation}

then $\vec S(t) = (x,y,z)^T$ satisfies
\begin{equation}
\dot{\vec S}(t) = A \vec S(t) .
\end{equation}

with
\[
A = 
\begin{pmatrix}
-(\Gamma + 2\Gamma_Z) & 0 & 0 \\
0 & -(\Gamma + 2\Gamma_Z) & 0 \\
0 & 0 & -2\Gamma
\end{pmatrix}.
\]

Solving yields the Pauli-error mixture:
\begin{equation}
\rho(t) = [1 - p(t)]\,\rho(0) 
+ p_x(t)\, X\, \rho(0)\, X 
+ p_y(t)\, Y\, \rho(0)\, Y
+ p_z(t)\, Z\, \rho(0)\, Z .
\end{equation}
\begin{equation}
p_x(t) = p_y(t) = \tfrac{1}{4}\!\left(1 - e^{-2\Gamma t}\right) .
\end{equation}
\begin{equation}
p_z(t) = \tfrac{1}{4}\!\left(1 + e^{-2\Gamma t} - 2 e^{-(\Gamma+2\Gamma_Z)t}\right) .
\end{equation}
\begin{equation}
p(t) = p_x(t) + p_y(t) + p_z(t) .
\end{equation}


Thus after syndrome measurement:
\[
\begin{cases}
\text{no error with prob. } 1 - p(t), \\
X \text{ error with prob. } p_x(t),\\
Y \text{ error with prob. } p_y(t),\\
Z \text{ error with prob. } p_z(t).\\
\end{cases}
\]

The time interval $t$ between correction cycles directly controls the error probability.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{More General Error Mappings}

Consider a general completely positive trace-preserving (CPTP) map:
\begin{equation}
\rho \;\longrightarrow\; \sum_k A_k^\dagger \rho A_k .
\end{equation}

with $\sum_k A_k^\dagger A_k = I$.

Example: a two-qubit operator
\begin{equation}
A_1 = \frac{Z_1 + i Z_2}{\sqrt{2}}, 
\qquad 
A_{k \neq 1} = 0 .
\end{equation}

representing correlated dephasing.

Then
\begin{equation}
A_1^\dagger \rho A_1 
= 
Z_1 \rho Z_1 + Z_2 \rho Z_2 
- i\, Z_1 \rho Z_2
+ i\, Z_2 \rho Z_1 .
\end{equation}


The last two cross-terms are \emph{coherent correlations} that are \underline{removed} by syndrome measurement. Let the ancilla block initially be $\rho^Z_0$. Then
\[
\begin{aligned}
&U_{\mathrm{QEC}}^\dagger \rho' \otimes \rho^Z_0 U_{\mathrm{QEC}} \\
&= 
Z_1 \rho Z_1 \otimes \lvert Z_1\rangle\langle Z_1\rvert
+ Z_2 \rho Z_2 \otimes \lvert Z_2\rangle\langle Z_2\rvert \\
&\hspace{6mm}
- i Z_1\rho Z_2 \otimes \lvert Z_1\rangle\langle Z_2\rvert
+ i Z_2\rho Z_1 \otimes \lvert Z_2\rangle\langle Z_1\rvert .
\end{aligned}
\]

After measuring the ancilla, only the diagonal terms survive:
\[
\begin{cases}
Z_1 \rho Z_1 \otimes \lvert Z_1\rangle\langle Z_1\rvert & \text{prob. } \tfrac12, \\[4pt]
Z_2 \rho Z_2 \otimes \lvert Z_2\rangle\langle Z_2\rvert & \text{prob. } \tfrac12.
\end{cases}
\]

Thus error correction again converts continuous and correlated noise into a \emph{single} discrete Pauli error on the codeword.

After syndrome extraction and measurement, any continuous or coherent error process acting on the encoded state is \emph{digitized} by the QEC procedure. Even if the physical noise produces superpositions of different error operators, the measurement of stabilizers removes all off--diagonal ``cross terms'' and collapses the state to a single discrete Pauli error acting on the codeword. Hence, the final density matrix after error correction takes the form of a single perturbation on an otherwise clean encoded state, with no correlated error remnants.

This digitization effect leads to a standard assumption in QEC analysis: after every elementary operation (gate application, measurement, initialization, or memory step), each qubit experiences a discrete error drawn from the Pauli set with some probability~$p$. That is,
\[
E =
\begin{cases}
I, & \text{with probability } 1-p,\\[4pt]
X\ \text{and/or}\ Z, & \text{with probability } p.
\end{cases}
\]


The set of possible discrete errors is determined by the ability of the quantum code to distinguish their corresponding syndromes. The magnitude of the underlying continuous physical noise is mapped into the probabilities of detecting these discrete Pauli errors.

In this way, the error correction analysis may assume perfect gates and treat noise as discrete, probabilistic Pauli faults whose probabilities are calculated independently from the physical error mechanisms. While this local, stochastic error model is widely used for threshold calculations and fault--tolerant circuit design, certain physical systems or quantum codes may require more sophisticated models due to correlations or non--Markovian effects.


\section{Bipartite Purification Protocols}
We shall noe discuss the main bipartite purification protocols - the BBPSSW protocol and the DEJMPS protocol which have been outlined in \cite{paper2}. Before we do that we shall define the following:

\begin{equation}
    | \phi_{00} \rangle = \frac{1}{\sqrt{2}} (|0\rangle_z |0\rangle_x + |1\rangle_z |1\rangle_x)
\end{equation}

Here $|0\rangle_z$ and $|1\rangle_z$ are the eigenstates of $\sigma_Z$ and $|0\rangle_x$ and $|1\rangle_x$ are the eigenstates of $\sigma_X$ with eigenvalues $\pm 1$ respectively. The other Bell states can be generated as follows:

\begin{equation}
    | \phi_{ij} \rangle = \sigma_z^i \sigma_z^j | \phi_{00} \rangle
\end{equation}

Here i, j control the operation on the first and second qubit respectively. We should also note that these bell states are eigenvectors for the operators

\begin{equation}
    K_1 = \sigma_x^i \sigma_z^j, \quad K_2 = \sigma_z^i \sigma_x^j
\end{equation}

with eigenvalues $(-1)^i$ and $(-1)^j$ respectively. We may use these bell bases vectors to express a mixed state $\rho_{AB}'$ shared between Alice and Bob as follows:

\begin{equation}
    \rho_{AB}' = \sum_{k_1, k_2, j_1, j_2 = 0}^{1} \lambda_{k_1 k_2 j_1 j_2} | \phi_{k_1 k_2} \rangle \langle \phi_{j_1 j_2} |
\end{equation}

Consider the operators $\{I, K_1, K_2, K_1 K_2\}$. If we apply say $K_1$ on the basis states $| \phi_{k_1 k_2} \rangle$, we get back the same state if $k_1 = 0$ and we get $- | \phi_{k_1 k_2} \rangle$ if $k_1 = 1$. Hence all off-diagonal terms (diagonal entries are those where $k_1 = j_1$ and $k_2 = j_2$) in $\rho_{AB}'$ will assume the form $(-1)^{k_1 \oplus j_1} | \phi_{k_1 k_2} \rangle \langle \phi_{j_1 j_2} |$. Now if we consider probabilistic application of $K_1$ then the density operator will be transformed as follows:

\begin{equation}
    \rho_{AB}' \rightarrow (1-p)\rho_{AB}' + p K_1 \rho_{AB}' K_1^\dagger
\end{equation}

And for $p = 0.5$, we see that all off diagonal terms where $k_1 \neq j_1$ will vanish. Similarly we can cancel out the other off-diagonal terms by application of an appropriate operator. We shall now claim the following.

\begin{claim}
    The procedure outlined above does not affect the fidelty of the state.
\end{claim}

\begin{proof}
    Let $\rho' = \sum_{k \in K} \alpha_k k \rho k^\dagger$ where $K$ is the above set of operators and $\alpha_k$ are probabilities. Then we have:
    \begin{equation}
        \begin{aligned}
            F(\rho') &= \langle \phi_{00} | \rho' | \phi_{00} \rangle \\
            &= \sum_{k \in K} \alpha_k \langle \phi_{00} | k \rho k^\dagger | \phi_{00} \rangle \\
            &= \sum_{k \in K} \alpha_k \langle \phi_{00} | \rho | \phi_{00} \rangle \\
            &= F(\rho)
        \end{aligned}
    \end{equation}
    This is because $k | \phi_{00} \rangle = | \phi_{00} \rangle$ for all $k \in K$.
\end{proof}

\cite{paper2} also highlights that we can indeed reduce this further so that only the diagonal terms remain. This is done by applying the operators of the form $U \otimes HU^*H$ as it leaves $| \phi_{00} \rangle$ invariant upto a phase and transforms the other bell states.

\begin{claim}
    Operators of the form $U \otimes HU^*H$ leave $| \phi_{00} \rangle$ invariant upto a phase.
\end{claim}

\begin{proof}
    Consider the state $| \phi^+ \rangle = \frac{1}{\sqrt{2}} (|0\rangle_z |0\rangle_z + |1\rangle_z |1\rangle_z)$. We can represent the defined bell states $| \phi_{00} \rangle$ in terms of $| \phi^+ \rangle$ as follows:

    \begin{equation}
        | \phi_{00} \rangle = (I \otimes H) | \phi^+ \rangle
    \end{equation}

    Also note  that $(U \otimes U^*) | \phi^+ \rangle = | \phi^+ \rangle$. Using this we get:

    \begin{equation}
        \begin{aligned}
            (U \otimes HU^*H) | \phi_{00} \rangle &= (U \otimes HU^*H)(I \otimes H) | \phi^+ \rangle \\
            &= (U \otimes HU^*) | \phi^+ \rangle \\
            &= (I \otimes H) (U \otimes U^*) | \phi^+ \rangle = | \phi_{00} \rangle
        \end{aligned}
    \end{equation}
\end{proof}

This allows us to simplify the density matrix to a Werner state of the form:

\begin{equation}
    \rho_w(x) = x | \phi_{00} \rangle \langle \phi_{00} | + \frac{1-x}{4} I_4
\end{equation}

Fidelity of the state is given by $F = \langle \phi_{00} | \rho_w(x) | \phi_{00} \rangle = \frac{3x + 1}{4}$ and we see that we can reduce any state with fidelity $F$ to a Werner form. Hence any entanglement purification protocol that works for Werner states will work for any general state with the same fidelity.

\subsection{BBPSSW Protocol}
This protocol enables creation of a maximally entangled state from several copies of a mixed state $\rho$, assuming that the fidelity $F$ with some maximally entangled state is greater than $1/2$. It proceeds as follows:

\begin{enumerate}
    \item Depolarize the state $\rho$ to a Werner form $\rho_w(F)$.
    \item Apply bilateral CNOT operations $U_{\text{CNOT}}^{A_1 \rightarrow A_2} \otimes U_{\text{CNOT}}^{B_1 \rightarrow B_2}$ on two copies of $\rho_w(F)$.
    \item Measure qubits $A_2$ and $B_2$ in the eigenbasis of $\sigma_z$, $\sigma_x$ respectively. Let the results be $(-1)^{\zeta}$ and $(-1)^{\xi}$ respectively.
    \item Keep the pair $A_1 B_1$ if $\zeta = \xi$.
\end{enumerate}

\subsubsection{Fidelity After One Purification Step}

Let the initial fidelity of the Werner state be $F$.
After one successful purification round, the state of the surviving pairs
remains Werner form with fidelity $F'$ given by
\begin{equation}
F' = \frac{F^2 + \left(\frac{1-F}{3}\right)^2}
{F^2 + \frac{2F(1-F)}{3} + 5\left(\frac{1-F}{3}\right)^2}.
\label{eq:BBPSSW_map}
\end{equation}
The denominator is the \emph{success probability} of the purification step:
\begin{equation}
p_{\text{succ}} = F^2 + \frac{2F(1-F)}{3} + 5\left(\frac{1-F}{3}\right)^2.
\end{equation}

Note that after the bilateral CNOT we have:

\begin{equation}
    |\phi_{k_1 k_2}\rangle_{A_1 B_1} |\phi_{j_1 j_2}\rangle_{A_2 B_2} \rightarrow |\phi_{k_1 \oplus j_1, k_2}\rangle_{A_1 B_1} |\phi_{j_1, k_2 \oplus j_2}\rangle_{A_2 B_2}
\end{equation}

Then we select states in $A_2B_2$ which are eigenstates of the operator $K_2^{A_2 B_2}$ with eigenvalue 1, that is only those states where $k_2 \oplus j_2 = 0$. If we write our Werner state as:

\begin{equation}
    \rho_w(F) = F | \phi_{00} \rangle \langle \phi_{00} | + \frac{1-F}{3} \sum_{(k_1, k_2) \neq (0,0)} | \phi_{k_1 k_2} \rangle \langle \phi_{k_1 k_2} |
\end{equation}

Then its evident that success probability = $(F + \frac{1-F}{3})^2 + 2(\frac{1-F}{3})^2$ and the new fidelity $F'$ is given by the ratio of the first term to the success probability. The control pair after the purification step is $(k_1 \oplus j_1, k_2)$ and the probability that this is $(0,0)$ is given by $F^2 + (\frac{1-F}{3})^2$. Thus we get the expression for $F'$ as given in equation \ref{eq:BBPSSW_map}. And not that this increases with the iterations.

\subsubsection{Asymptotic Behavior and Yield}

Although $p_{\text{succ}}\to1$ as $F\to1$, 
each purification round consumes two pairs and keeps only one.
Hence, the overall \emph{yield} of purified pairs,
defined as the ratio of output to input pairs, goes to zero in the limit
of infinite repetitions.

However, for any fixed target fidelity $F>1-\epsilon_0$,
a finite number of purification rounds suffices, giving a finite yield.

In practice, experimental imperfections (gate errors, decoherence, 
imperfect measurements) limit the achievable fidelity, so $F=1$
is of theoretical interest only.

\subsection{DEJMPS Protocol}
The DEJMPS protocol, introduced by Deutsch et al., is a recurrence protocol for entanglement purification that improves upon the earlier BBPSSW protocol. While BBPSSW is designed primarily for Werner states, the DEJMPS protocol operates effectively on the broader class of states diagonal in the Bell basis. Its primary advantage lies in its higher efficiency and its ability to purify states with heavy phase noise by introducing local basis rotations that convert phase errors into detectable bit-flip errors.

\subsubsection{Mathematical Setup}
We consider a bipartite system (Alice and Bob) described by the Bell basis states:
\begin{align}
    |\Phi^+\rangle &= \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle) \nonumber \\
    |\Phi^-\rangle &= \frac{1}{\sqrt{2}}(|00\rangle - |11\rangle) \nonumber \\
    |\Psi^+\rangle &= \frac{1}{\sqrt{2}}(|01\rangle + |10\rangle) \nonumber \\
    |\Psi^-\rangle &= \frac{1}{\sqrt{2}}(|01\rangle - |10\rangle)
\end{align}
An arbitrary state $\rho$ diagonal in the Bell basis can be described by four real coefficients $\lambda_{ij}$:
\begin{align}
    \rho = & \lambda_{00}|\Phi^+\rangle\langle\Phi^+| + \lambda_{01}|\Phi^-\rangle\langle\Phi^-| \\ &+ \lambda_{10}|\Psi^+\rangle\langle\Psi^+| + \lambda_{11}|\Psi^-\rangle\langle\Psi^-|
\end{align}
where $\sum \lambda_{ij} = 1$. Here, $\lambda_{00}$ represents the fidelity $F$ with respect to the ideal state $|\Phi^+\rangle$.

\subsubsection{Protocol Steps}
The protocol operates on two identical copies of the noisy state $\rho$, denoted as the source pair ($\rho_1$) and the target pair ($\rho_2$).

\begin{enumerate}
\item{Local Basis Rotation (The Twirl):}
Before the interaction, Alice and Bob apply local unitary operations $U_A$ and $U_B$ to their respective qubits in both pairs. This operation distinguishes DEJMPS from BBPSSW. The transformation is defined as:
\begin{align}
    U_A: |0\rangle_A &\to \frac{1}{\sqrt{2}}(|0\rangle_A - i|1\rangle_A),  \\
    |1\rangle_A &\to \frac{1}{\sqrt{2}}(|1\rangle_A - i|0\rangle_A) \nonumber \\
    U_B: |0\rangle_B &\to \frac{1}{\sqrt{2}}(|0\rangle_B + i|1\rangle_B),  \\
    |1\rangle_B &\to \frac{1}{\sqrt{2}}(|1\rangle_B + i|0\rangle_B)
\end{align}
This corresponds to a rotation $R_x(\frac{\pi}{2})$ on Alice's qubits and the inverse rotation $R_x(-\frac{\pi}{2})$ on Bob's qubits.

\textbf{Physical Interpretation:} This rotation permutes the Bell coefficients. Specifically, it swaps the population of the phase-error state $|\Phi^-\rangle$ ($\lambda_{01}$) with the bit-plus-phase error state $|\Psi^-\rangle$ ($\lambda_{11}$). This essentially converts phase errors into bit errors, which are detectable by the subsequent parity check.

\item{Bilateral CNOT Gate:}
Alice performs a CNOT gate using her qubit in pair 1 as the control and her qubit in pair 2 as the target. Bob does the same on his side. The transformation of two Bell states $|\Phi_{k_1 k_2}\rangle \otimes |\Phi_{j_1 j_2}\rangle$ under bilateral CNOT is given by \cite{paper2}:
\begin{equation}
    |\Phi_{k_1 k_2}\rangle |\Phi_{j_1 j_2}\rangle \xrightarrow{CNOT^{\otimes 2}} |\Phi_{k_1 \oplus j_1, k_2}\rangle |\Phi_{j_1, k_2 \oplus j_2}\rangle
\end{equation}
This operation propagates bit-flip errors ($k_1$ index) forward from source to target, and phase-flip errors ($k_2$ index) backward from target to source.

\item{Measurement and Post-Selection:}
Alice and Bob measure the target pair (pair 2) in the computational $Z$-basis ($|0\rangle, |1\rangle$). 
\begin{itemize}
    \item If the measurement results coincide ($00$ or $11$), the operation was likely error-free regarding bit-flips. The source pair is kept.
    \item If the results differ ($01$ or $10$), the source pair is discarded.
\end{itemize}
This measurement projects the target pair onto the subspace where $k_2 \oplus j_2 = 0$, effectively filtering out instances where bit-flip errors occurred in one pair but not the other.
\end{enumerate}

\subsubsection{Recursive Map for Density Matrix Coefficients}
If the purification step succeeds, the new coefficients $\lambda'_{ij}$ of the source pair are updated according to the following non-linear map derived in Ref \cite{paper2}:

\begin{align}
    \lambda'_{00} &= \frac{\lambda_{00}^2 + \lambda_{11}^2}{N} \label{eq:map1} \\
    \lambda'_{10} &= \frac{2\lambda_{00}\lambda_{11}}{N} \label{eq:map2} \\
    \lambda'_{01} &= \frac{\lambda_{01}^2 + \lambda_{10}^2}{N} \label{eq:map3} \\
    \lambda'_{11} &= \frac{2\lambda_{01}\lambda_{10}}{N} \label{eq:map4}
\end{align}

where $N$ is the probability of success (normalization factor):
\begin{equation}
    N = (\lambda_{00} + \lambda_{11})^2 + (\lambda_{01} + \lambda_{10})^2
\end{equation}
\subsubsection{Convergence and Threshold}
The recursive map defined by Eqs. (\ref{eq:map1})-(\ref{eq:map4}) possesses an attracting fixed point at:
\begin{equation}
    \lambda_{00} = 1, \quad \lambda_{01}=\lambda_{10}=\lambda_{11}=0
\end{equation}
This implies that iteration of the protocol drives the state toward the maximally entangled state $|\Phi^+\rangle$. The purification is successful for any state where the initial fidelity $F = \lambda_{00} > 1/2$. 

Crucially, compared to BBPSSW, the DEJMPS protocol:
\begin{enumerate}
    \item Converges faster (requires fewer resources for the same target fidelity).
    \item Has a higher threshold for local gate noise ($p_{min} \approx 0.96$ for BBPSSW vs $p_{min}$ significantly lower for DEJMPS).
    \item Can effectively purify states dominated by phase noise (which BBPSSW cannot efficiently handle).
\end{enumerate}
\section{One-Way Entanglement Purfication}

The \cite{Equivalence} paper describes how we can construct one-way entanglement purification protocols (1-EPP) which basically involve Alice and Bob performing local operations and measurements on their respective sharded bits. We now deviate from the usual 2-EPP protocols (like BBPSSW) and have only Alice communicate her measuremnt results to Bob. Bob now uses these in conjunction with his own menasurments and performs local operations to recover the entangled state. One such protocol is one-way hashing.

\subsection{One-Way Hashing}

We shall now describe one such protocol called one-way hashing. The basic idea here is that Alice and Bob start of n impure pairs drawn from a Bell-diagonal state of the form:

\begin{equation}
    \rho = \sum_{i,j=0}^{1} p_{ij} \ket{\phi_{ij}} \bra{\phi_{ij}}
\end{equation}

Where $\ket{\phi_{00}} = \ket{\Phi^+}$, $\ket{\phi_{01}} = \ket{\Psi^+}$, $\ket{\phi_{10}} = \ket{\Phi^-}$ and $\ket{\phi_{11}} = \ket{\Psi^-}$. Hence bit $i$ denotes phase error and bit $j$ denotes amplitude error. We then sacrifice some of these pairs to gain information about the remaining ones. Once we know the error syndromes, we can apply appropriate corrections to get maximally entangled pairs. The protocol proceeds as follows:

\begin{enumerate}
    \item At the start of the $(k+1)^{\text{th}}$ round, both share $n-k$ impure pairs represented by the error vector $x_k$ for $k = 0, 1, \ldots, n-m-1$.
    \item Alice chooses a random $2(n-k)$ bit string $s$ and sends it to Bob.
    \item Both of them then perform unitary operations to compute $s \cdot x_k$. 
    \item Disard the pair used here and repeat till we have $m$ pairs left. The state of these pairs can be determined using the previously obtained $s \cdot x_k$ values.
    \item Bob applies appropriate corrections to get maximally entangled pairs.
\end{enumerate}

\cite{Equivalence} shows that the optimal value of $n - m \approx nS(\rho)$ where $S(\rho)$ is the von Neumann entropy of the state $\rho$. Hence the yield of this protocol is given by $m/n \approx 1 - S(\rho)$. We shall now describe this protocol and its workings in more detail.

\subsection{Calculating Parities Using Unitary Operations}

We encode each of the Bell states $\ket{\phi_{ij}}$ as a 2-bit string $ij$. Hence the state of n pairs can be represented as a $2(n-k)$ bit string $s$. Recall that the bit $i$ represents phase error and bit $j$ represents amplitude error. We choose the destination pair as the first pair corresponding to the non-zero bit of $s$. For example if $s = 00 11 10 01$, then we choose $11$ as the detination pair and our goal is to map $s \cdot x_k$ to the amplitude bit of this pair. Note that any $00$ pairs in $s$ can be ignored as they do not contribute to the parity. We now have the following cases:

\begin{table}[h]
    \centering
    \caption{Parity-computation cases}
    \renewcommand{\arraystretch}{1.6}  % Increase row height
    \setlength{\tabcolsep}{20pt}       % Increase column spacing
    \begin{tabular}{c | c | c }
        \hline
        \textbf{Case} & \textbf{Operation} & \textbf{Gates} \\
        \hline
        01 & Do nothing & I \\
        10 & Swap $i$ and $j$ bits & $B_y$ \\
        11 & Do $j \to i \oplus j$ & $B_x \sigma_x$ \\
        \hline
    \end{tabular}
\end{table}

Here $B_y = R_y(\pi/2) \otimes R_y(\pi/2)$ and $B_x = R_x(\pi/2) \otimes R_x(\pi/2)$. These gates have the following action on the Bell states (upto a global phase):

\begin{equation}
    \begin{aligned}
        B_y &: \ket{\phi_{ij}} \rightarrow \ket{\phi_{ji}} \\
        B_x &: \ket{\phi_{ij}} \rightarrow \ket{\phi_{i, i \oplus j \oplus 1}}
    \end{aligned}
\end{equation}

Since $B_x$ gate XORs an extra 1 to the amplitude bit, we need to apply an additional $\sigma_x$ gate to correct for that. Once this is done for all pairs in $s$, we perform bilateral CNOT operations using each source pair as control and the destination pair as target. Finally performing measurement in bell basis on the destination pair gives us the required parity $s \cdot x_k$. For the example above, the circuit would look like:

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.45\textwidth]{OWHash.png}
    \caption{One-Way Hashing}
    \label{fig:OWHashCircuit}
\end{figure}

A $\Phi$ state implies 0 parity and a $\Psi$ state implies 1 parity. Hence the remaining pairs form $x_{k+1} = f_{s_k}(x_k)$. Let $b_k$ denote the measurement result (0 or 1) at round $k$. The remaining bell states are characterized by the string $x_{k+1} \in \mathbb{Z}_2^{2(n-k-1)}$ and this string can be determined from the previous string $x_k$ and $s_k$ once we know $f_{s_k}$. Once we have $m$ pairs left, we can determine the error syndromes and apply appropriate corrections to get maximally entangled pairs.

\subsection{Optimization of Sacrificial Pairs}

Before optimizing for $m$, we first note that the probability of two different error strings $x$ and $y$ giving same parity for a random $s$ is $1/2$. This is true as $P(s \cdot x = s \cdot y) = P(s \cdot (x \oplus y) = 0)$ and since we know that $x \oplus y \neq 0$ WLOG, assume that the first bit of $x \oplus y$ is 1 at some postions indexed by the set $I$. Then clearly our inner product reduces to:

\begin{equation}
    s \cdot (x \oplus y) = \sum_{i \in I} s_i
\end{equation}

As $s$ is random, the probability that this sum is 0 is $1/2$. We also consider the typical set $\mathcal{T}_\epsilon^{n}$ which is defined as:

\begin{equation}
    \mathcal{T}_\epsilon^{n} = \left\{ x \in \mathbb{Z}_2^{2n} : \left| -\frac{1}{n} \log_2 p(x) - S(\rho) \right| \leq \epsilon \right\}
\end{equation}

Note that as $n \rightarrow \infty$ we have:

\begin{equation}
    P(x \in \mathcal{T}_\epsilon^{n}) = P\left(\left| -\frac{1}{n} \log_2 p(x) - S(\rho) \right| \leq \epsilon\right) \to 1
\end{equation}

as the left hand side tends to 0 by LLN. We can also bound the size of this typical set as follows:

\begin{equation}
    (1 - \epsilon) 2^{n(S(\rho) - \epsilon)} \leq |\mathcal{T}_\epsilon^{n}| \leq 2^{n(S(\rho) + \epsilon)}
\end{equation}

Hence as $n \rightarrow \infty$, we have $|\mathcal{T}_\epsilon^{n}| \approx 2^{nS(\rho)}$. We now consider strings $x_k$ and $y_k$ which were formed by subjecting the strings $x_0$ and $y_0$ to $k$ rounds of one-way hashing with same $s_0, s_1, \ldots, s_{k-1}$. From this we have:

\begin{equation}
    P((x_k \neq y_k) \land \forall j \ s_j \cdot x_j = s_j \cdot y_j) \leq 2^{-k}
\end{equation}

Since we know that $x \in \mathcal{T}_\epsilon^{n}$ w.p atleast $1 - \epsilon$, after r = $n - m$ rounds of hashing, we can bound the failure probability as follows:

\begin{equation}
    \begin{aligned}
        P_{\text{fail}} &\leq P(x_0 \notin \mathcal{T}_\epsilon^{n}) \\
        &\quad + \sum_{y_j \in \mathcal{T}_\epsilon^{n}} P(x_j \neq y_j \land \forall j \ s_j \cdot (x_j \oplus y_j) = 0) \\
        &\leq \epsilon + |\mathcal{T}_\epsilon^{n}| 2^{-r} \\
        &\leq \epsilon + 2^{n(S(\rho) + \epsilon) - (n - m)} \\
    \end{aligned}
\end{equation}

By choosing $m = n(1 - S(\rho) - \epsilon)$, we can make $P_{\text{fail}}$ arbitrarily small as $n \rightarrow \infty$. Hence the yield of this protocol is given by $m/n \approx 1 - S(\rho)$.

\section{One-Way EPP and QECC Equivalence}
The main idea outlined in \cite{Equivalence} is that a one-way entanglement purification protocol (1-EPP) can be transformed into a quantum error-correcting code (QECC) and vice versa. Let $\mathcal{Q}(\chi(M))$ denote the quantum channel capacity of a channel $\chi$ and let $D(M)$ denote the one-way distillable entanglement of a mixed state $M$. We show that $\mathcal{Q}(\chi(M)) \leq D(M)$ and $D(M) \leq \mathcal{Q}(\chi(M))$ thus proving the equivalence. Both of these proofs are constructive in nature.

\subsection{QECC implies 1-EPP}

Consider a quantum teleportation protocol where Alice and Bob share mixed states $M$ instead of $\ket{\Phi^+}$. We may represent $M$ as:

\begin{equation}
    \rho_M = \sum_{i, j = 0}^{1} p_{ij} \ket{\phi_{ij}} \bra{\phi_{ij}}
\end{equation}  

Hence, with probability $p_{00}$, the teleportation works perfectly, else the final state is affected by some bit-flip or phase-flip error. We construct the following purification protocol:

\begin{enumerate}
    \item Alice prepares to send $n$ qubits by first creating $m$ $\ket{\phi_{00}}$ states and encoding half of each and $n-m$ ancilla qubits using a QECC.
    \item This encoded state is then teleported to Bob over the noisy channel using $n$ copies of $M$.
    \item Bob applies the error-correction procedure of the QECC to recover the $m$ half of the $\ket{\phi_{00}}$ states along with the $n-m$ ancilla qubits.
\end{enumerate}

Clearly we were able to purify $m$ maximally entangled states from $n$ copies of $M$ using only one-way classical communication from Alice to Bob. Hence, by using a QECC with rate $m/n$, we were able to construct a 1-EPP with yield atleast $m/n$. Thus we have $\mathcal{Q}(\chi(M)) \leq D(M)$.

\subsection{1-EPP implies QECC}
Consider a 1-EPP protocol which purifies $m$ maximally entangled states from $n$ copies of a mixed state $M$ using only one-way classical communication. We construct the following QECC:

\begin{enumerate}
    \item Alice and Bob apply the 1-EPP protocol on $n$ copies of $M$ to obtain $m = nD(M)$ maximally entangled states.
    \item Alice then prepares $m$ qubits of the state she wants to send and teleports them to Bob using the $m$ maximally entangled states.
\end{enumerate}

Hence by using a 1-EPP with yield $m/n$, we were able to construct a QECC with rate atleast $m/n$ as we were able to send $m$ qubits. This involved the use of only one-way classical communication from Alice to Bob. \cite{Equivalence} further proves that we can achieve the same rate without any classical communication. Thus we have $D(M) \leq \mathcal{Q}(\chi(M))$. Thus we have proved the equivalence between 1-EPP and QECC.

\section{Implementation and Experimental Results}
In terms of implementation, we have used Qiskit to simulate the 3-bit and 9-bit Shor code. The codes can be found in the Codes directory of the \href{https://github.com/jaymehta132/QuantumErrorCorrection-EE7001}{repository}. The methodology used and results obtained are mentioned as follows: 
\subsection{3-bit Code for X error}

\href{https://github.com/jaymehta132/QuantumErrorCorrection-EE7001/blob/main/Codes/scripts/3bitCode.py}{This code} implements the three-qubit bit-flip quantum error correction protocol, which protects a logical qubit against a single bit-flip error by encoding, detecting, and correcting errors using quantum gates and measurements. The process begins by encoding a logical qubit into three physical qubits through a Hadamard gate and two CNOT gates, creating an entangled state that distributes the quantum information. A deliberate bit-flip error is then introduced on one of the physical qubits to simulate noise. To detect and locate the error, two ancilla qubits are entangled with the data qubits using CNOT gates, and their measurement reveals the error syndrome without collapsing the encoded quantum information. Based on the measured syndrome, a conditional correction is applied: the corresponding qubit is flipped if an error is detected, ensuring the logical state is restored. Finally, the logical qubit is decoded back to a single qubit and measured to verify successful error correction. The simulation results are visualized and saved, demonstrating the effectiveness of the protocol in correcting single bit-flip errors while preserving quantum coherence.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/3bitCode/3bitCodeCircuit.png}
    \caption{3-bit Code Circuit for X error}
    \label{fig:3bitCodeCircuit}
\end{figure}

The first Hadamard gate is to convert the basis from Z-basis to X-basis. The next two CNOT gates are used to encode the qubit. The X gate is used to introduce an error in the second qubit. The next four CNOT gates are used to detect the error using two ancilla qubits. The measurement of the ancilla qubits gives us the error syndrome which is then used to correct the error using conditional X gates. Finally, we decode the qubit using two CNOT gates and a Hadamard gate and measure it. 

The results obtained are as follows:
\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/3bitCode/3bitCodeHistogram.png}
    \caption{3-bit Code Results for X error}
    \label{fig:3bitCodeResults} 
\end{figure}

The last two bits in the histogram represent the ancilla qubits used for error detection. The first bit represents the output of the measurement of the corrected qubit in the X-basis. The results show that the output is "001" with a probability of 1, indicating that the error correction was successful and the logical qubit was restored to its original state. 

\subsection{3-bit Code for Phase error}
\href{https://github.com/jaymehta132/QuantumErrorCorrection-EE7001/blob/main/Codes/scripts/3bitPhaseEC.py}{This code} simulates the effectiveness of the three-qubit bit-flip quantum error correction code in suppressing small coherent errors, specifically single-qubit X rotations of magnitude $\epsilon$. It first calculates the fidelity of an unencoded qubit state $|0\rangle$ after the error, showing that the fidelity drops by approximately $\epsilon^2$. Next, it encodes the state into three qubits using CNOT gates, applies the same error to all three data qubits, and simulates syndrome extraction using two ancilla qubits via further CNOT gates. The code then post-selects the component where no error is detected (syndrome '00'), normalizes this state, and decodes it back to a single qubit. The fidelity of the corrected, decoded state is calculated and shown to be suppressed to order $\epsilon^6$, demonstrating the power of quantum error correction: the probability of error is reduced from quadratic to sixth order in $\epsilon$. The code outputs and compares both fidelities, confirming that the encoded and corrected state retains much higher fidelity than the unencoded state, as expected from theory.
\begin{figure}[h!]
    \centering

    \begin{subfigure}[b]{0.3\columnwidth}
        \centering
        \includegraphics[width=\textwidth]{../Codes/results/3bitPhaseEC/EncodingCircuit.png}
        \caption{Encoding Circuit}
        \label{fig:3bitPhaseECCircuit}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\columnwidth}
        \centering
        \includegraphics[width=\textwidth]{../Codes/results/3bitPhaseEC/SyndromeMeasurementCircuit.png}
        \caption{Syndrome Measurement Circuit}
        \label{fig:3bitPhaseDecodingCircuit}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\columnwidth}
        \centering
        \includegraphics[width=\textwidth]{../Codes/results/3bitPhaseEC/DecodingCircuit.png}
        \caption{Decoding Circuit}
        \label{fig:3bitPhaseAncillaCircuit}
    \end{subfigure}

    \caption{3-bit Code Circuits for Phase error}
    \label{fig:three_images}
\end{figure}

The first circuit (Fig. \ref{fig:3bitPhaseECCircuit}) encodes the qubit using two CNOT gates. The second circuit (Fig. \ref{fig:3bitPhaseDecodingCircuit}) performs syndrome measurement using two ancilla qubits and four CNOT gates. The third circuit (Fig. \ref{fig:3bitPhaseAncillaCircuit}) decodes the qubit back to a single qubit using two CNOT gates. 

The above circuit when implemented in Qiskit shows that the fidelity of the encoded qubit is indeed $1-\epsilon^6$ instead of the $1-\epsilon^2$ of the unencoded qubit.

\subsection{9-bit Shor Code to correct Z error}
\href{https://github.com/jaymehta132/QuantumErrorCorrection-EE7001/blob/main/Codes/scripts/9bitCode.py}{This code} demonstrates the full process of quantum error correction using the 9-qubit Shor code, which protects a single logical qubit against arbitrary single-qubit phase-flip (Z) errors by encoding it into nine physical qubits. The procedure begins by encoding the logical qubit $|+\rangle$ using a layered approach: first, a three-qubit phase-flip code is applied, and then each of those three qubits is further encoded with a three-qubit bit-flip code, resulting in a 3x3 block structure. After encoding, a phase-flip (Z) error is deliberately injected on one chosen qubit to simulate noise.

To detect and locate the error, the code performs syndrome extraction using six ancilla qubits. Each block of three data qubits is rotated into the X basis with Hadamard gates, and parity checks are performed using CNOT gates and ancilla measurements. The measured syndrome bits reveal which qubit in each block is affected by a phase error. Based on the syndrome, the code determines which physical qubits require a Z correction and applies it.

The final circuit repeats the encoding, injects the same error, applies the determined corrections, and then decodes the logical qubit back to a single qubit using the inverse of the encoding operations. To verify successful error correction, the logical qubit is measured in the X basis; in an ideal simulation, the outcome should be deterministic, confirming that the logical state has been restored. This process illustrates how the Shor code can reliably detect and correct any single-qubit error, preserving quantum information against both bit-flip and phase-flip errors.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/9bitCode/SyndromeMeasurementCircuit.png}
    \caption{Syndrome Measurement Circuit for 9-bit Code}
    \label{fig:9bitCodeResults}
\end{figure}
The first block encodes the qubit using CNOT and Hadamard gates. The second block adds the Z error in the 2nd qubit. The third block performs the syndrome measurement using 6 ancilla qubits. These measurements are then used to determine the error and correct it which is done in the next circuit.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/9bitCode/FinalCircuit.png}
    \caption{9-bit Shor Code Circuit for Z error}
    \label{fig:9bitCodeCircuit}
\end{figure}

The first two blocks are the same as above. The third block performs the error correction and the final block decodes the qubit back to a single qubit and measures it.

The results obtained are as follows:
\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/9bitCode/FinalHistogram.png}
    \caption{9-bit Code Results for Z error}
    \label{fig:9bitCodeHistogram}
\end{figure}

This histogram shows that the output is "0" with a probability of 1, indicating that the error correction was successful and the logical qubit was restored to its original state as the final measurement is done in the X-basis.

\subsection{Generating Encoded States for [7, 1, 3] Code}

This code implements the circuit to generate the encoded states $\ket{0}_L$ and $\ket{1}_L$ for the [7, 1, 3] code using its stabilizers. The state $\ket{0}_L$ is given by:

\begin{equation}
    \begin{aligned}
        \ket{0}_L = \frac{1}{\sqrt{8}} (&\ket{0000000} + \ket{1010101} \\ 
        + &\ket{0110011} + \ket{1100110} + \ket{0001111} \\
        + &\ket{1011010} + \ket{0111100} + \ket{1101001})
    \end{aligned}  
\end{equation}

The circuit for the zero state was constructed exactly as given in \cite{paper1} using stabilizers. We then measure all qubits to verify the final state. The circuits and results are as follows:

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/Stabilizer/Circuit_EncZero.png}
    \caption{Circuit for encoded state $\ket{0}_L$}
\end{figure}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/Stabilizer/EncZero_Results.png}
    \caption{Final Measurements for $\ket{0}_L$}
\end{figure}

We can do the same for the encoded state $\ket{1}_L$ by applying a logical X gate to $\ket{0}_L$. The logical X gate for this code is given by $X_L = X_1 X_2 X_3$. The circuit and results are as follows:

\begin{equation}
    \begin{aligned}
        \ket{1}_L = \frac{1}{\sqrt{8}} (&\ket{1111111} + \ket{0101010} \\ 
        + &\ket{1001100} + \ket{0011001} + \ket{1110000} \\
        + &\ket{0100101} + \ket{1000011} + \ket{0010110})
    \end{aligned}
\end{equation}


\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/Stabilizer/Circuit_EncOne.png}
    \caption{Circuit for encoded state $\ket{1}_L$}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/Stabilizer/EncOne_Results.png}
    \caption{Final Measurements for $\ket{1}_L$}
\end{figure}

\subsection{BBPSSW Protocol}

We also verify the working of this protocol for werner states with initial fidelity $F > 0.5$. We use a more simplified circuit for the protocol without the stabilizer operations as given in \cite{paper2} as we only really need to analyse fidelity improvement and not how a werner state is created. We run this cicuit using an input werner state with fidelity values greater than 0.5 and measure the output fidelity. We also keep track of the success probability of the protocol. The results are as follows:

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/BBPSSW/PurificationCircuit.png}
    \caption{BBPSSW Protocol Circuit}
    \label{fig:BBPSSWCircuit}
\end{figure} 

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/BBPSSW/FidelityPlot.png}
    \caption{Fidelity Improvement using BBPSSW Protocol}
    \label{fig:BBPSSWResults}
\end{figure}

\subsection{DEJMPS Protocol}
We implemented a comparative simulation of the DEJMPS protocol using Qiskit. The experiment initialized a system of two noisy Bell pairs using \texttt{SetDensityMatrix}, constructing a specific input state with an initial fidelity of $F_{in} = 0.8000$ and a noise profile dominated by phase errors (the $|\Phi^-\rangle$ component). For the DEJMPS implementation, we introduced conjugate local rotations---applying $R_x(\frac{\pi}{2})$ to Alice's qubits and $R_x(-\frac{\pi}{2})$ to Bob's---prior to the standard bilateral CNOT gates used in BBPSSW. The experimental results highlighted the critical advantage of this basis change: the BBPSSW protocol failed to purify the state, resulting in a reduced fidelity of $0.7320$, as the standard CNOT parity check is insensitive to Z-errors and propagates them across the control qubits. In contrast, the DEJMPS protocol successfully increased the fidelity to $0.9007$. This confirms that the local rotations effectively converted the dominant Z-errors into X-errors, allowing the subsequent parity check to detect and filter the noise, thereby validating the protocol's robustness against phase-biased noise.

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/DEJMPS/PurificationCircuit.png}
    \caption{DEJMPS Protocol Circuit}
    \label{fig:DEJMPSCircuit}
\end{figure} 

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.45\textwidth]{../Codes/results/DEJMPS/FidelityPlot.png}
    \caption{Superiority of DEJMPS over BBPSSW Protocol}
    \label{fig:DEJMPSResults}
\end{figure}


\section{Conclusion}
This report has provided a comprehensive overview of Quantum Error Correction (QEC) and Entanglement Purification, two complementary and essential strategies for overcoming the inherent fragility of quantum systems against noise and decoherence

\subsection{Summary of Key Findings and Protocols}
We first established the critical need for error mitigation by detailing various types of quantum errors, including coherent errors, environmental decoherence, and practical imperfections such as loss, leakage, measurement, and initialization errors. We then reviewed the fundamental QEC protocols that form the basis of fault-tolerant quantum computation:
\begin{itemize}
    \item \textbf{3-Qubit Bit-Flip Code:} This simple yet illustrative code protects against single bit-flip errors by encoding a logical qubit into three physical qubits. We demonstrated how syndrome measurement using ancilla qubits allows for error detection and correction, improving fidelity from $1-\epsilon^2$ to $1-\epsilon^6$ for small coherent errors.
    \item \textbf{9-Qubit Shor Code:} This more sophisticated code extends protection to arbitrary single-qubit errors (both bit-flip and phase-flip) by combining bit-flip and phase-flip codes. We highlighted its degenerate nature and the use of multiple ancilla qubits for syndrome extraction, showcasing its ability to restore logical qubits with high fidelity.
\end{itemize}
In addition to QEC, we reviewed bipartite entanglement purification protocols, specifically the BBPSSW protocol. This protocol enables the distillation of high-fidelity entangled states from multiple noisy copies, which is crucial for reliable quantum communication and teleportation.We demonstrated how it converts multiple noisy entangled pairs into fewer pairs with higher fidelity, using bilateral CNOT operations and post-selection based on measurement outcomes.

\subsection{Significance and Future Outlook}
The successful simulation of the 3-bit and 9-bit codes using Qiskit validates the theoretical frameworks of QEC. Together, QEC and entanglement purification provide the theoretical and practical foundation for building fault-tolerant quantum information processing systems. By bridging the gap between fragile quantum hardware and the robust manipulation of information, these techniques are pivotal for the future realization of large-scale quantum communication, computation, and cryptography. Continued research and experimental progress in both areas will be essential to fully harness the power of quantum technologies.
\bibliographystyle{IEEEtran}
\bibliography{refs.bib}

\end{document}